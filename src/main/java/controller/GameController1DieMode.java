package controller;

import model.Board;
import model.Piece;
import model.Player;
import model.Square.NormalSquare;
import model.Square.Square;
import persistence.AssetManager;

import java.util.ArrayList;
import java.util.Random;

/**
 * Provides the object controller of the game with the responsibility of intermediating the viewController and the model and the persistence
 */
public class GameController1DieMode {

    private Player currentPlayer;
    private Player[] players;
    private int movingNumber;
    private int dieRepetition;
    private Board board;
    private int maxSteps = 56;
    private int isThereAWinner;

    private final AssetManager assetManager;


    /**
     * This is the constructor. All game attributes are set to 0, the players and board are initiated and an instance of
     * the AssetManager class is assigned to the assetManager attribute.
     */
    public GameController1DieMode() {
        createPlayers();
        movingNumber = 0;
        dieRepetition = 0;
        board = new Board();
        isThereAWinner = 0;
        assetManager = AssetManager.getInstance();
    }

    private void createPlayers() {
        players = new Player[4];
        for (int i = 0; i < players.length; i++) {
            players[i] = new Player(i+1,"Player " + (i+1));
        }
        currentPlayer = players[0];
    }

    /**
     * Changes player from the players array assigned to the attribute currentPlayer.
     * <p>
     *     The order followed is player 1, player 2, player 3, player 4 and then player 1
     *     since the index go from 0 to 3 and then 0 again.
     * </p>
     */
    public void nextPlayer(){
        int nextPlayerPos = currentPlayer.getIdNumber();
        if(nextPlayerPos==4){
            nextPlayerPos=0;
        }
        currentPlayer = players[nextPlayerPos];
    }

    /**
     * Get the player whose turn is to move.
     * @return Player object corresponding to the current player.
     */
    public Player getCurrentPlayer(){
        return currentPlayer;
    }

    /**
     * Get the integer associated with the number of steps the current player should move at that moment.
     * @return int the number corresponding to movingNumber.
     */
    public int getMovingNumber(){
        return movingNumber;
    }

    /**
     * Get the game board in its current state.
     * @return Board the board corresponding to the board attribute
     */
    public Board getBoard(){return board;}


    /**
     * Simulate a regulated die roll from parcheesi and assigning the result to movingNumber if it required.
     * <p>
     *     The die roll keeps track on the repetitions generated by rolling 6s and does not proceed normally
     *     when a roll is repeated 3 times. The die can only be roller if movingNumber is <0 which implies the
     *     previous movement has been completed.
     * </p>
     * @return int resulting number of the die roll or -1 in case a third repetition roll has taken place.
     */
    // Method to simulate die rolling between 1 and 6 with special cases for rolling 5 and 6
    public int diceRoll(){

        if(movingNumber > 0){
            return 0;
        }

        Random randomGenerator = new Random();
        int die1Value = randomGenerator.nextInt(6) + 1;

        if(die1Value != 6){
            dieRepetition = 0;
        }

        if(die1Value == 5){
            if(newPieceEnters(currentPlayer.getIdNumber())){
                movingNumber = 0;
                nextPlayer();
                return 5;
            }
        }

        if(die1Value == 6){
            dieRepetition++;
        }

        if(dieRepetition == 3){
            repetitionPunishment();
            movingNumber = 0;
            nextPlayer();
            return -1;
        }

        movingNumber = die1Value;

        //Check if a piece has left the house already. If all pieces are in the house the number on the die is irrelevant
        if(board.getHousePieces()[currentPlayer.getIdNumber()-1] == 4){
            movingNumber = 0;
            if(die1Value != 6) {
                nextPlayer();
            }
        }

        return die1Value;
    }


    /**
     * Verify that after rolling a 5 a new piece of the player who rolled it can enter the board
     * <p>
     *     A piece won't be able to enter if there are none left to enter because they are all on board.
     *     Neither will a piece enter if the starting square is blocked be two pieces
     * </p>
     * @param player this is the player that rolled a 5
     * @return boolean. True if a piece of the argument player can enter the board and false otherwise.
     */
    //Method to handle rolling a 5 which may require a piece entering
    public boolean newPieceEnters(int player){

        //First check if there are still pieces in the house
        if(board.getNumberOfPiecesInHouse(player)<1){
            return false;
        }

        //Declaring starting square for the corresponding player
        int startingBoardPosition = board.getStartSquares()[player-1]-1;
        NormalSquare playerStartingNormalSquare = board.getBoardSquares()[startingBoardPosition];

        //Check if the square is blocked by the presence of two pieces
        if(playerStartingNormalSquare.isBlocked()){
            return false;
        }

        //Put piece in starting square
        playerStartingNormalSquare.enterPiece(currentPlayer.getIdNumber());
        board.exitPieceFromHouse(player);
        return true;

    }


    /**
     * Manages the consequences for the board when current player rolling the die three continuous times.
     * <p>
     *     These consequences are the return to the house of the most advanced piece of the current player
     *    , the one who rolled the die three times.
     * </p>
     */
    //Method to remove most advance piece that is not in the final squares
    public void repetitionPunishment(){

        int punishedPlayer = currentPlayer.getIdNumber();
        //first make sure there is a piece on the board
        if(board.getNumberOfPiecesInHouse(punishedPlayer) == 4){
            return;

        }

        boolean mostAdvancePunished = board.punishMostAdvancePiece(punishedPlayer);

        //Stop the punishment if there has not been any piece punishable for that player
        if(!mostAdvancePunished){
            return;
        }

        //If a punishable piece has been removed do the following with the board:
        board.returnPieceToHouse(punishedPlayer);
    }

    //Methods related to moving piece after it has been clicked
    /**
     * Based on the position clicked by a player this method verify the clicked square of the board
     * is correct for the movement this means it contains a piece of the player who is moving.
     * Serves as buffer for actionless clicks or clicking when it doesn't correspond.
     * @param position int corresponding to the numerical index of the board square
     * @param playerIfFinalSquare int associated with the player that clicked, but it is only used if
     *                            a final square of the board was clicked.
     * @return boolean true if the area clicked contained a piece of the player clicking. false if the
     * are clicked is empty or contains another players piece
     */
    public boolean verifySquareClickedAndGameState(int position, int playerIfFinalSquare){

        //The die has not been thrown
        if(movingNumber == 0) return false;

        //If a final square that does not correspond to the current player was clicked
        if(currentPlayer.getIdNumber() != playerIfFinalSquare && playerIfFinalSquare>0) return false;

        //The square clicked does not have a piece or one that corresponds to the current player
        boolean isCorrectPieceThere = checkPlayerPieceInBoardPosition(position,playerIfFinalSquare);

        return isCorrectPieceThere;
    }

    /**
     * Confirms the present of a piece of current player in clicked square.
     * @param boardPosition int corresponding to the numerical index of the board square
     * @param playerIfFinalSquare int associated with the player that clicked, but it is only used if
     *                            a final square of the board was clicked.
     * @return
     */
    //Method to verify the presence of a corresponding piece in a position of the board. BoardPosition is an integer associated with the square in the board
    // For normal squares goes from 0 to 59 and for final squares from 0 to 6
    public boolean checkPlayerPieceInBoardPosition(int boardPosition,int playerIfFinalSquare){

        int possiblePlayerPieceInSquare1 = 0;
        int possiblePlayerPieceInSquare2 = 0;


        //Reject action if there is no piece in the place clicked.
        //Check if the piece clicked is on the normal board squares
        if(playerIfFinalSquare == 0 && !board.getBoardSquares()[boardPosition].getCurrentPieces().isEmpty()) {
            ArrayList<Piece> currentSquarePieces = board.getBoardSquares()[boardPosition].getCurrentPieces();
            possiblePlayerPieceInSquare1 = currentSquarePieces.get(0).getPlayer();
            if(currentSquarePieces.size() == 2) {
                possiblePlayerPieceInSquare2 = currentSquarePieces.get(1).getPlayer();
            }
        }

        //Check if the piece clicked is on the final board squares
        if(playerIfFinalSquare > 0 && !board.getFinalSquaresBoard()[playerIfFinalSquare-1][boardPosition].getCurrentPieces().isEmpty()) {
            ArrayList<Piece> currentSquarePieces = board.getFinalSquaresBoard()[playerIfFinalSquare-1][boardPosition].getCurrentPieces();
            possiblePlayerPieceInSquare1 = currentSquarePieces.get(0).getPlayer();
            if(currentSquarePieces.size() == 2) {
                possiblePlayerPieceInSquare2 = currentSquarePieces.get(1).getPlayer();
            }
        }

        if (possiblePlayerPieceInSquare1 == currentPlayer.getIdNumber() || possiblePlayerPieceInSquare2 == currentPlayer.getIdNumber()) {
            return true;
        }

        return false;
    }


    /**
     * Change the model classes adequately to simulate the change in the position of a piece in the board and
     * confirming the move's completion.
     * <p>
     *     It also assigns the value of 10 or 20 to the moving number if the moving piece finishes the board or eats
     *     another rival piece and waits for the decision of the same player. If none of this happens it also changes
     *     current player.
     * </p>
     * @param boardPosition int indicating the index in the board of piece before movement
     * @param playerIfFinal int the number of the player if the position of the piece before moving is a final square
     * @return boolean confirm the piece has moved adequately which could mean moving less if it found a block.
     */
    public boolean movePiece(int boardPosition,int playerIfFinal){

        //Get theoretically piece in the corresponding board position that is about to move the number established by the die
        Piece movingPiece = getPieceInBoardPosition(currentPlayer.getIdNumber(), boardPosition, playerIfFinal);

        if(movingPiece == null){
            System.out.println("No piece was found even though it fitted all criteria");
            return false;
        }

        //Check for barriers. If there is a barrier the moving number will now be steps to barrier minus 1
        int stepsToBarrier = checkForBarriers(boardPosition, movingNumber);
        //If the steps of the piece go over 56 before  the barrier position is irrelevant for the movement
        if(movingNumber >= stepsToBarrier && movingPiece.getStepCounter() + stepsToBarrier < maxSteps){
            movingNumber = stepsToBarrier-1; //if barrier is encounter before reaching final squares the movement becomes steps to barrier minus 1.
        }

        //Change the step counter and calculate and get square where the piece is moving to
        Square newSquare;
        movingPiece.move(movingNumber);
        newSquare = board.getCorrespondingBoardSquare(currentPlayer.getIdNumber(), movingPiece.getFinalStepCounter(), movingPiece.getStepCounter());

        //Now knowing the square the piece will occupy we check if this square is the end or if a piece has been captured before moving the piece here
        //The corresponding changes to the conditions are also applied

        //Check if piece has reached the end
        if(newSquare.isTheEnd()) {
            newSquare.setCurrentPiece(movingPiece);
            board.pieceReachesTheEnd(currentPlayer.getIdNumber());
            newSquare.getCurrentPieces().remove(0);

            if(board.getHousePieces()[currentPlayer.getIdNumber() - 1] < 4 - board.getFinishedPieces(currentPlayer.getIdNumber())){
                movingNumber = 10;
            } else {
                movingNumber = 0;
            }
            //Check if this is the final piece
            isThereAWinner();
            return true;
        }

        if(hasMovingPieceCapturedAnotherPiece(newSquare)){
            newSquare.setCurrentPiece(movingPiece);
            movingNumber = 20;
            return true;
        }

        //If there is no particular event we simply change the attributes of the piece on the new position to match those of the moving piece
        newSquare.setCurrentPiece(movingPiece);

        movingNumber = 0;
        if(dieRepetition == 0){
            nextPlayer();
        }
        return true;
    }

    private Piece getPieceInBoardPosition(int piecePlayer,int boardPosition, int playerIfFinalSquares){
        //Get and modify correct Piece in board position
        ArrayList<Piece> currentSquarePieces = board.getBoardSquares()[boardPosition].getCurrentPieces();
        if(playerIfFinalSquares > 0) {
            currentSquarePieces = board.getFinalSquaresBoard()[playerIfFinalSquares-1][boardPosition].getCurrentPieces();
        }
        Piece movingPiece = null;

        if(!currentSquarePieces.isEmpty()) {
            if (currentSquarePieces.get(0).getPlayer() == piecePlayer) {
                movingPiece = currentSquarePieces.get(0);
                currentSquarePieces.remove(0);
            } else if (currentSquarePieces.get(1).getPlayer() == piecePlayer) {
                movingPiece = currentSquarePieces.get(1);
                currentSquarePieces.remove(1);
            }
        }
        return movingPiece;
    }

    //This method goes along the squares a piece goes through if there is a barrier the method returns the steps to the barrier encounter
    private int checkForBarriers( int startingBoardPosition, int movingSteps){
        int stepsToBarrier = 60;
        for (int i = 1; i < movingSteps+1; i++) {
           Square testedSquareForBarrier = board.getBoardSquares()[(startingBoardPosition+i)%60];
           if(testedSquareForBarrier.isBlocked()){
               stepsToBarrier = i;
               break;
           }
        }
        return stepsToBarrier;
    }

    private boolean hasMovingPieceCapturedAnotherPiece(Square squareWherePieceIsAboutToMoveTo){

        //Dismiss capturing if square is Safe
        if(squareWherePieceIsAboutToMoveTo.isSafe()){return  false;}

        //Dismiss Capturing if empty
        if(squareWherePieceIsAboutToMoveTo.getCurrentPieces().isEmpty()){return  false;}

        int possibleCapturedPlayerPiece = squareWherePieceIsAboutToMoveTo.getCurrentPieces().get(0).getPlayer();
        if(possibleCapturedPlayerPiece != 0 && possibleCapturedPlayerPiece != currentPlayer.getIdNumber()){
            board.returnPieceToHouse(possibleCapturedPlayerPiece);
            return true;
        }
        return false;
    }

    /**
     * Confirm a player has won
     * @return boolean true if all pieces of a player have reached the end
     */
    public boolean isThereAWinner(){
        return isThereAWinner != 0;
    }

    //METHODS FOR IMAGE HANDLING

    /** Get from the persistence the corresponding image of the die in the form of a byte array.
     * @param dieImageLocation String which corresponds to the final part of the path of the desired die image.
     *                         These are composed of the player that rolled and the number that appeared in the die.
     * @return byte[] byte array corresponding to the desired die image
     */
    public byte[] getDieImageData(String dieImageLocation){
        return assetManager.getDieImageData(dieImageLocation);
    }

    /** Get from the persistence the corresponding image of the trophy in the form of a byte array.
     * @param player int between 1 and 4 corresponding to the player who won to get its trophy version
     * @return byte[] byte array corresponding to the desired trophy image
     */
    public  byte[] getTrophyImageData(int player){return assetManager.getTrophyImageData(player);}

    /** Get from the persistence the corresponding image of the piece in the form of a byte array.
     * @param playerPieces String that corresponds to two numbers which indicate the combination of pieces desired.
     *                     If only the piece corresponding to player 2 was required it would be 02. If both player 3 and
     *                     player 1 had a piece and the square is safe it would be 13. If player 4 had two pieces in one
     *                     square forming a barrier it would be 44.
     * @param orientation String informing of the orientation of the piece image required depending on the position of
     *                    the square in the board.
     * @return byte[] byte array corresponding to the desired piece image
     */
    public byte[] getPieceImageData(String playerPieces, String orientation){
        return assetManager.getPieceImageData(playerPieces, orientation);
    }

    /** Get from the persistence the corresponding image of the board in the form of a byte array.
     * @return byte[] byte array corresponding to the desired board image
     */
    public byte[] getBoardImageData(){
        return assetManager.getBoardImageData(1);
    }


    // METHODS EXCLUSIVE FOR QUICK TESTING
    public boolean onlyForTestSetMovingNumber(int number){
        movingNumber = number;
        return true;
    }

    public int onlyForTestGetMovingNumber(){
        return movingNumber;
    }

    public int isThereAWinner(int player) {
        int numberOfPiecesFinished = board.getFinishedPieces(player);
        if(numberOfPiecesFinished==4) {
            isThereAWinner = player;
        }
        return isThereAWinner;
    }

}
